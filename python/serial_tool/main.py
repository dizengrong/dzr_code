#!/usr/bin/env python
# -*- coding: utf8 -*-
#
# generated by wxGlade 0.6.8 (standalone edition) on Tue Aug 06 20:54:05 2013
#

import wx, os, serial, threading, serialRxEvent, util
import xdrlib, sys, xlrd, tenjin, time, datetime, webbrowser
from serialRxEvent import SerialRxEvent
from tenjin.escaped import *
from deviceListCtrl import DeviceListCtrl
from util import PortSetting, Device
from wxTerm import *

# begin wxGlade: dependencies
import gettext
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

# 端口设置字段
ENUM_SETTING_DESC       = 0
ENUM_SETTING_RATE       = 1
ENUM_SETTING_BYTESIZE   = 2
ENUM_SETTING_PARITY     = 3
ENUM_SETTING_STOPBITS   = 4
ENUM_SETTING_DTRCONTROL = 5

engine = tenjin.SafeEngine()



def to_str(value):
	if isinstance(value, float):
		if int(value) == value: return str(int(value))
		else: return str(value)
	else:
		return unicode(value)


class MyFrame1(wx.Frame):
	def __init__(self, *args, **kwds):
		# begin wxGlade: MyFrame1.__init__
		kwds["style"]           = wx.DEFAULT_FRAME_STYLE
		wx.Frame.__init__(self, *args, **kwds)
		self.notebook_3         = wx.Notebook(self, wx.ID_ANY, style=0)
		self.notebook_3_pane_1  = wx.Panel(self.notebook_3, wx.ID_ANY)
		self.select_port        = wx.StaticText(self.notebook_3_pane_1, wx.ID_ANY, _(u"选择端口"))
		self.ports_combobox     = wx.ComboBox(self.notebook_3_pane_1, wx.ID_ANY, choices=self.ScanPort(), style=wx.CB_DROPDOWN)
		self.setting            = wx.StaticText(self.notebook_3_pane_1, wx.ID_ANY, _(u"选择设置"))
		self.setting_combobox   = wx.ComboBox(self.notebook_3_pane_1, wx.ID_ANY, choices=self.InitPortSetting(), style=wx.CB_DROPDOWN)
		self.open_port_btn      = wx.Button(self.notebook_3_pane_1, wx.ID_ANY, _(u"打开端口"))
		self.sizer_13_staticbox = wx.StaticBox(self.notebook_3_pane_1, wx.ID_ANY, _(u"端口"))
		self.window_1           = wx.SplitterWindow(self.notebook_3_pane_1, wx.ID_ANY, style=wx.SP_3D | wx.SP_BORDER)
		self.window_1_pane_1    = wx.Panel(self.window_1, wx.ID_ANY)
		self.dev_listctrl       = self.SetupDeviceListCtrl(self.window_1_pane_1)
		self.label_7            = wx.StaticText(self.window_1_pane_1, wx.ID_ANY, _(u"选择命令模板"))
		self.cmd_tpl_combobox   = wx.ComboBox(self.window_1_pane_1, wx.ID_ANY, choices=self.InitCmdTemplates(), style=wx.CB_DROPDOWN)
		self.gen_cmd_btn        = wx.Button(self.window_1_pane_1, wx.ID_ANY, _(u"生成"))
		self.tpl_output         = wx.TextCtrl(self.window_1_pane_1, wx.ID_ANY, "", style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_RICH)
		self.label_8            = wx.StaticText(self.window_1_pane_1, wx.ID_ANY, _(u"发送间隔（毫秒）："))
		self.send_interval      = wx.TextCtrl(self.window_1_pane_1, wx.ID_ANY, "1000")
		self.send_btn           = wx.Button(self.window_1_pane_1, wx.ID_ANY, _(u"发送"))
		self.window_1_pane_2    = wx.Panel(self.window_1, wx.ID_ANY)
		self.output             = TermEmulator(self.window_1_pane_2, wx.ID_ANY, "", style=wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_RICH)
		self.input              = wx.TextCtrl(self.window_1_pane_2, wx.ID_ANY, "", style=wx.TE_MULTILINE | wx.TE_RICH)
		self.sizer_19_staticbox = wx.StaticBox(self.window_1_pane_2, wx.ID_ANY, "")

		self.__set_properties()
		self.__do_layout()
		# end wxGlade

		# init serial port
		self.serial          = serial.Serial()
		self.serial.timeout  = 0.5

		self.CreateStatusBar()
		self.SetupMenu()

		self.thread = None
		self.alive  = threading.Event()
		self.send_thread = None

		# 事件
		self.Bind(wx.EVT_BUTTON, self.OnOpenPort, self.open_port_btn)
		self.Bind(wx.EVT_BUTTON, self.OnGenCmd, self.gen_cmd_btn)
		self.Bind(wx.EVT_BUTTON, self.OnSendTplCmd, self.send_btn)
		# self.Bind(wx.EVT_TEXT_ENTER, self.OnInput, self.input)
		self.input.Bind(wx.EVT_TEXT, self.OnInputChanged)

	def __set_properties(self):
		# begin wxGlade: MyFrame1.__set_properties
		self.SetTitle(_(u"MyPortManager"))
		self.SetSize((802, 586))
		self.output.SetBackgroundColour(wx.Colour(0, 0, 0))
		self.window_1.SetMinSize((773, 465))
		# end wxGlade

	def __do_layout(self):
		# begin wxGlade: MyFrame1.__do_layout
		sizer_11 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_12 = wx.BoxSizer(wx.VERTICAL)
		self.sizer_19_staticbox.Lower()
		sizer_19 = wx.StaticBoxSizer(self.sizer_19_staticbox, wx.VERTICAL)
		sizer_18 = wx.BoxSizer(wx.VERTICAL)
		sizer_21 = wx.BoxSizer(wx.HORIZONTAL)
		sizer_20 = wx.BoxSizer(wx.HORIZONTAL)
		self.sizer_13_staticbox.Lower()
		sizer_13 = wx.StaticBoxSizer(self.sizer_13_staticbox, wx.HORIZONTAL)
		sizer_13.Add(self.select_port, 0, wx.ALL | wx.EXPAND, 2)
		sizer_13.Add(self.ports_combobox, 0, wx.ALL | wx.EXPAND, 2)
		sizer_13.Add(self.setting, 0, wx.ALL | wx.EXPAND, 2)
		sizer_13.Add(self.setting_combobox, 0, wx.ALL | wx.EXPAND, 2)
		sizer_13.Add(self.open_port_btn, 0, wx.ALL | wx.EXPAND, 2)
		sizer_12.Add(sizer_13, 0, wx.EXPAND, 0)
		sizer_18.Add(self.dev_listctrl, 1, wx.ALL | wx.EXPAND, 0)
		sizer_20.Add(self.label_7, 0, wx.ALL | wx.EXPAND, 2)
		sizer_20.Add(self.cmd_tpl_combobox, 0, wx.ALL | wx.EXPAND, 2)
		sizer_20.Add(self.gen_cmd_btn, 0, wx.ALL | wx.EXPAND, 2)
		sizer_18.Add(sizer_20, 0, wx.EXPAND, 0)
		sizer_18.Add(self.tpl_output, 1, wx.ALL | wx.EXPAND, 0)
		sizer_21.Add(self.label_8, 0, wx.ALL | wx.EXPAND, 2)
		sizer_21.Add(self.send_interval, 0, wx.ALL | wx.EXPAND, 2)
		sizer_21.Add(self.send_btn, 0, wx.ALL | wx.EXPAND, 0)
		sizer_18.Add(sizer_21, 0, wx.EXPAND, 0)
		self.window_1_pane_1.SetSizer(sizer_18)
		sizer_19.Add(self.output, 7, wx.ALL | wx.EXPAND, 0)
		sizer_19.Add(self.input, 1, wx.ALL | wx.EXPAND, 0)
		self.window_1_pane_2.SetSizer(sizer_19)
		self.window_1.SplitVertically(self.window_1_pane_1, self.window_1_pane_2)
		sizer_12.Add(self.window_1, 1, wx.ALL | wx.EXPAND, 0)
		self.notebook_3_pane_1.SetSizer(sizer_12)
		self.notebook_3.AddPage(self.notebook_3_pane_1, _(u"设备控制"))
		sizer_11.Add(self.notebook_3, 1, wx.EXPAND, 0)
		self.SetSizer(sizer_11)
		self.Layout()
		# end wxGlade

	def SetupMenu(self):
		# 文件菜单栏
		filemenu          = wx.Menu()
		menu_import_excel = filemenu.Append(wx.ID_ANY, u"导入数据", u" 导入设备excel数据")
		filemenu.AppendSeparator()
		menu_exit         = filemenu.Append(wx.ID_EXIT, u"退出", u" 关闭程序")
		
		# 关于菜单栏
		aboutmenu         = wx.Menu()
		menu_doc          = aboutmenu.Append(wx.ID_ANY, u"&文档", u" 文档")
		menu_about        = aboutmenu.Append(wx.ID_ABOUT, u"&关于", u" 关于")


		# Creating the menubar.
		menubar = wx.MenuBar()
		menubar.Append(filemenu, u"文件")
		menubar.Append(aboutmenu, u"帮助")
		self.SetMenuBar(menubar)

		# set events
		self.Bind(wx.EVT_MENU, self.dev_listctrl.OnImportDeviceDatas, menu_import_excel)
		self.Bind(wx.EVT_MENU, self.OnExit, menu_exit)
		self.Bind(wx.EVT_MENU, self.OnAbout, menu_about)        
		self.Bind(wx.EVT_MENU, self.OnOpenDoc, menu_doc)

	def OnOpenDoc(self, event):
		doc = os.path.join(os.path.realpath(os.path.dirname(".")), "documents/index.html")
		webbrowser.open(doc)

	def OnOpenPort(self, e):
		if self.serial.isOpen():
			self.alive.clear()
			self.serial.close()
			util.SendToTerm(self.output, self.GetId(), u"端口已断开！\n", serialRxEvent.FROM_TYPE_SYS)
			self.open_port_btn.SetLabel(U"打开端口")
			return

		if self.ports_combobox.GetSelection() == wx.NOT_FOUND:
			dlg = wx.MessageDialog(self, u"请选择端口", u"错误", wx.OK)
			dlg.ShowModal()
			dlg.Destroy()
			return
		if self.setting_combobox.GetSelection() == wx.NOT_FOUND:
			dlg = wx.MessageDialog(self, u"请选择端口设置", u"错误", wx.OK)
			dlg.ShowModal()
			dlg.Destroy()
			return
		portstr = self.ports_combobox.GetStringSelection()
		port_setting = self.setting_list[self.setting_combobox.GetSelection()]

		print port_setting.stopBits

		
		self.serial.port     = portstr
		self.serial.baudrate = port_setting.baudRate
		self.serial.bytesize = port_setting.byteSize
		self.serial.stopbits = port_setting.stopBits
		self.serial.parity   = port_setting.parity
		self.serial.rtscts   = port_setting.dtrControl
		try:
			self.serial.open()
			self.StartThread()
			util.SendToTerm(self.output, self.GetId(), u"端口打开成功！\n", serialRxEvent.FROM_TYPE_SYS)
			self.open_port_btn.SetLabel(u"断开")
		except Exception, e:
			raise e

	def OnAbout(self, e):
		dlg = wx.MessageDialog(self, u"设备配置程序v1.01", u"关于", wx.OK)
		dlg.ShowModal()
		dlg.Destroy()

	def OnExit(self, e):
		if self.send_thread is not None:
			self.send_thread.join()
			self.send_thread = None
		self.serial.close()
		self.StopThread()
		self.Close(True)

	def InitPortSetting(self):
		xml_data = xlrd.open_workbook("PortSetting.xls")
		table    = xml_data.sheet_by_index(0)
		desc_list = []
		self.setting_list = []
		for i in range(1, table.nrows):
			desc_list.append(to_str(table.cell(i, ENUM_SETTING_DESC).value))

			port_setting = PortSetting(int(table.cell(i, ENUM_SETTING_RATE).value),
									   int(table.cell(i, ENUM_SETTING_BYTESIZE).value),
									   to_str(table.cell(i, ENUM_SETTING_PARITY).value),
									   int(table.cell(i, ENUM_SETTING_STOPBITS).value),
									   int(table.cell(i, ENUM_SETTING_DTRCONTROL).value))
			self.setting_list.append(port_setting)
		return desc_list

	def ScanPort(self):
		available = []
		for i in range(256):
			try:
				s = serial.Serial(i)
				available.append(s.portstr)
				s.close()
			except serial.SerialException:
				pass
		return available

	def InitCmdTemplates(self):
		self.tpl_list = []
		desc_list = []
		for item in os.listdir("templates/"):
			if item.endswith(".txt"):
				tpl = os.path.basename(item)
				self.tpl_list.append(tpl)
				desc_list.append(tpl)
		return desc_list

	def SetupDeviceListCtrl(self, parent):
		self.dev_listctrl = DeviceListCtrl(parent, wx.ID_ANY, style=wx.LC_REPORT | wx.LC_HRULES | wx.LC_VRULES)
		self.dev_listctrl.SetMainFrame(self)
		return self.dev_listctrl

	def StartThread(self):
		"""Start the receiver thread"""        
		self.thread = threading.Thread(target=self.ComPortThread)
		self.thread.setDaemon(1)
		self.alive.set()
		self.thread.start()

	def StopThread(self):
		"""Stop the receiver thread, wait util it's finished."""
		if self.thread is not None:
			self.alive.clear()          #clear alive event for thread
			self.thread.join()          #wait until thread has finished
			self.thread = None

	def ComPortThread(self):
		"""Thread that handles the incomming traffic. Does the basic input
		   transformation (newlines) and generates an SerialRxEvent"""
		while self.alive.isSet():               #loop while alive event is true
			# text = self.serial.read(1)          #read one, with timout注意该进程是在这里会阻塞的
			# if text:                            #check if not timeout
			#     n = self.serial.inWaiting()     #look if there is more to read
			#     if n:
			#         text = text + self.serial.read(n) #get it
			#     event = SerialRxEvent(self.GetId(), text)
			#     self.GetEventHandler().AddPendingEvent(event)
			text  = self.serial.readline()
			if text:
				util.SendToTerm(self.output, self.GetId(), text, serialRxEvent.FROM_TYPE_PORT)

	def OnInputChanged(self, event):
		content = self.input.GetValue()
		if content == '\n':
			self.input.Clear()
			return
		if content[-1:] == '\n':
			if self.AssertSerial():
				self.StartSendTplCmdThread(content.split("\n")[:-1], self.GetSendInterval())
				self.input.Clear()
				print "send: %s" % (content)
			else:
				self.input.Clear()

	def GetSendInterval(self):
		send_interval = 1000
		try:
			send_interval = int(self.send_interval.GetValue())
		except Exception, e:
			self.send_interval.SetValue("1000")
		return send_interval

	def OnGenCmd(self, event):
		if self.cmd_tpl_combobox.GetSelection() == wx.NOT_FOUND:
			util.SendToTerm(self.output, self.GetId(), u"请选择模板\n", serialRxEvent.FROM_TYPE_SYS)
			return
		device = self.dev_listctrl.GetSelectedDevice()
		if device == None:
			util.SendToTerm(self.output, self.GetId(), u"请选择一条设备数据\n", serialRxEvent.FROM_TYPE_SYS)
			return

		tpl_file = "templates/" + self.cmd_tpl_combobox.GetStringSelection()
		print tpl_file
		dict_data = {"mangr_vlan": device.mangr_vlan,
					 "mangr_ip": device.mangr_ip,
					 "submask_ip": device.submask_ip,
					 "begin_vlan": device.begin_vlan,
					 "end_vlan": device.end_vlan,
					 "gateway_ip": device.gateway_ip
					 }
		content  = engine.render(tpl_file, dict_data)
		self.tpl_output.SetValue(content)

	def OnSendTplCmd(self, event):
		tpl_content = self.tpl_output.GetValue()
		if tpl_content == '':
			util.SendToTerm(self.output, self.GetId(), u"还没有生成命令\n", serialRxEvent.FROM_TYPE_SYS)
			return
		if not self.AssertSerial():
			return
		send_interval = self.GetSendInterval()

		cmd_list = self.tpl_output.GetValue().split("\n")
		self.StartSendTplCmdThread(cmd_list, send_interval)

	def StartSendTplCmdThread(self, cmd_list, send_interval):
		self.send_thread = threading.Thread(target=self.SendTplCmdThread, args = (cmd_list, send_interval))
		self.send_thread.setDaemon(1)
		self.send_thread.start()

	def SendTplCmdThread(self, cmd_list, send_interval):
		for cmd in cmd_list:
			self.serial.write(cmd + "\n")
			util.SendToTerm(self.output, self.GetId(), cmd + "\n", serialRxEvent.FROM_TYPE_SEND)
			time.sleep(send_interval/1000.0)

			if not self.serial.isOpen():
				util.SendToTerm(self.output, self.GetId(), u"连接已断开！\n", serialRxEvent.FROM_TYPE_SYS)
				break
			# self.output.send_event.wait(1.5)
			# if not self.output.send_event.isSet(): # 如果设备没响应，再等待超时1.5秒
			# 	total_wait_time = send_interval/1000.0 + 1.5
			# 	util.SendToTerm(self.output, self.GetId(), u"发送: " + cmd + u"超时" + str(total_wait_time) + u"秒，发送中断！\n", serialRxEvent.FROM_TYPE_SYS)
			# 	break
			# else:
			# 	self.output.send_event.clear()

		self.send_thread = None

	def AssertSerial(self):
		if not self.serial.isOpen():
			util.SendToTerm(self.output, self.GetId(), u"端口还没打开\n", serialRxEvent.FROM_TYPE_SYS)
			return False
		else:
			return True

# end of class MyFrame1
if __name__ == "__main__":
	gettext.install("app") # replace with the appropriate catalog name

	app = wx.PySimpleApp(0)
	wx.InitAllImageHandlers()
	frame_1 = MyFrame1(None, wx.ID_ANY, "")
	app.SetTopWindow(frame_1)
	frame_1.Show()
	app.MainLoop()